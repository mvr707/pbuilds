/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.04 from the
 * contents of Declare.xs. Do not edit this file, edit Declare.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Declare.xs"
#define PERL_NO_GET_CONTEXT 1
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "hook_op_check.h"
#undef printf
#include "stolen_chunk_of_toke.c"
#include <stdio.h>
#include <string.h>

#define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#define PERL_DECIMAL_VERSION \
  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#define PERL_VERSION_GE(r,v,s) \
  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))

#ifndef Newx
# define Newx(v,n,t) New(0,v,n,t)
#endif /* !Newx */

#define DD_DEBUGf_UPDATED_LINESTR 1
#define DD_DEBUGf_TRACE 2

#define DD_DEBUG_UPDATED_LINESTR (dd_debug & DD_DEBUGf_UPDATED_LINESTR)
#define DD_DEBUG_TRACE (dd_debug & DD_DEBUGf_TRACE)
static int dd_debug = 0;

#define DD_CONST_VIA_RV2CV PERL_VERSION_GE(5,11,2)

#define DD_GROW_VIA_BLOCKHOOK PERL_VERSION_GE(5,13,3)

#define LEX_NORMAL    10
#define LEX_INTERPNORMAL   9

/* please try not to have a line longer than this :) */

#define DD_PREFERRED_LINESTR_SIZE 16384

/* flag to trigger removal of temporary declaree sub */

static int in_declare = 0;

/* in 5.10, PL_parser will be NULL if we aren't parsing, and PL_lex_stuff
   is a lookup into it - so if anything else we can use to tell, so we
   need to be a bit more careful if PL_parser exists */

#define DD_AM_LEXING_CHECK (PL_lex_state == LEX_NORMAL || PL_lex_state == LEX_INTERPNORMAL)

#if defined(PL_parser) || defined(PERL_5_9_PLUS)
#define DD_HAVE_PARSER PL_parser
#define DD_HAVE_LEX_STUFF (PL_parser && PL_lex_stuff)
#define DD_AM_LEXING (PL_parser && DD_AM_LEXING_CHECK)
#else
#define DD_HAVE_PARSER 1
#define DD_HAVE_LEX_STUFF PL_lex_stuff
#define DD_AM_LEXING DD_AM_LEXING_CHECK
#endif

/* thing that decides whether we're dealing with a declarator */

int dd_is_declarator(pTHX_ char* name) {
  HV* is_declarator;
  SV** is_declarator_pack_ref;
  HV* is_declarator_pack_hash;
  SV** is_declarator_flag_ref;
  int dd_flags;
  char* curstash_name;

  is_declarator = get_hv("Devel::Declare::declarators", FALSE);

  if (!is_declarator)
    return -1;

  /* $declarators{$current_package_name} */

  curstash_name = HvNAME(PL_curstash);
  if (!curstash_name)
    return -1;

  is_declarator_pack_ref = hv_fetch(is_declarator, curstash_name,
                             strlen(curstash_name), FALSE);

  if (!is_declarator_pack_ref || !SvROK(*is_declarator_pack_ref))
    return -1; /* not a hashref */

  is_declarator_pack_hash = (HV*) SvRV(*is_declarator_pack_ref);

  /* $declarators{$current_package_name}{$name} */

  is_declarator_flag_ref = hv_fetch(
    is_declarator_pack_hash, name,
    strlen(name), FALSE
  );

  /* requires SvIOK as well as TRUE since flags not being an int is useless */

  if (!is_declarator_flag_ref
        || !SvIOK(*is_declarator_flag_ref)
        || !SvTRUE(*is_declarator_flag_ref))
    return -1;

  dd_flags = SvIVX(*is_declarator_flag_ref);

  return dd_flags;
}

/* callback thingy */

void dd_linestr_callback (pTHX_ char* type, char* name) {

  char* linestr = SvPVX(PL_linestr);
  int offset = PL_bufptr - linestr;

  dSP;

  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(newSVpv(type, 0)));
  XPUSHs(sv_2mortal(newSVpv(name, 0)));
  XPUSHs(sv_2mortal(newSViv(offset)));
  PUTBACK;

  call_pv("Devel::Declare::linestr_callback", G_VOID|G_DISCARD);

  FREETMPS;
  LEAVE;
}

char* dd_get_linestr(pTHX) {
  if (!DD_HAVE_PARSER) {
    return NULL;
  }
  return SvPVX(PL_linestr);
}

void dd_set_linestr(pTHX_ char* new_value) {
  unsigned int new_len = strlen(new_value);

  if (SvLEN(PL_linestr) < new_len) {
    croak("PL_linestr not long enough, was Devel::Declare loaded soon enough in %s",
      CopFILE(&PL_compiling)
    );
  }


  memcpy(SvPVX(PL_linestr), new_value, new_len+1);

  SvCUR_set(PL_linestr, new_len);

  PL_bufend = SvPVX(PL_linestr) + new_len;

  if ( DD_DEBUG_UPDATED_LINESTR && PERLDB_LINE && PL_curstash != PL_debstash) {
    /* Cribbed from toke.c */
    AV *fileav = CopFILEAV(&PL_compiling);
    if (fileav) {
      SV * const sv = NEWSV(85,0);

      sv_upgrade(sv, SVt_PVMG);
      sv_setpvn(sv,PL_bufptr,PL_bufend-PL_bufptr);
      (void)SvIOK_on(sv);
      SvIV_set(sv, 0);
      av_store(fileav,(I32)CopLINE(&PL_compiling),sv);
    }
  }
}

char* dd_get_lex_stuff(pTHX) {
  return (DD_HAVE_LEX_STUFF ? SvPVX(PL_lex_stuff) : "");
}

void dd_clear_lex_stuff(pTHX) {
  if (DD_HAVE_PARSER)
    PL_lex_stuff = (SV*)NULL;
}

char* dd_get_curstash_name(pTHX) {
  return HvNAME(PL_curstash);
}

int dd_get_linestr_offset(pTHX) {
  char* linestr;
  if (!DD_HAVE_PARSER) {
    return -1;
  }
  linestr = SvPVX(PL_linestr);
  return PL_bufptr - linestr;
}

char* dd_move_past_token (pTHX_ char* s) {

  /*
   *   buffer will be at the beginning of the declarator, -unless- the
   *   declarator is at EOL in which case it'll be the next useful line
   *   so we don't short-circuit out if we don't find the declarator
   */

  while (s < PL_bufend && isSPACE(*s)) s++;
  if (memEQ(s, PL_tokenbuf, strlen(PL_tokenbuf)))
    s += strlen(PL_tokenbuf);
  return s;
}

int dd_toke_move_past_token (pTHX_ int offset) {
  char* base_s = SvPVX(PL_linestr) + offset;
  char* s = dd_move_past_token(aTHX_ base_s);
  return s - base_s;
}

int dd_toke_scan_word(pTHX_ int offset, int handle_package) {
  char tmpbuf[sizeof PL_tokenbuf];
  char* base_s = SvPVX(PL_linestr) + offset;
  STRLEN len;
  char* s = scan_word(base_s, tmpbuf, sizeof tmpbuf, handle_package, &len);
  return s - base_s;
}

int dd_toke_scan_ident(pTHX_ int offset) {
    char tmpbuf[sizeof PL_tokenbuf];
    char* base_s = SvPVX(PL_linestr) + offset;
    char* s = scan_ident(base_s, PL_bufend, tmpbuf, sizeof tmpbuf, 0);
    return s - base_s;
}

int dd_toke_scan_str(pTHX_ int offset) {
  char* old_pvx = SvPVX(PL_linestr);
  SV* line_copy = sv_2mortal(newSVsv(PL_linestr));
  char* base_s = SvPVX(PL_linestr) + offset;
  char* s = scan_str(base_s, FALSE, FALSE);
  if(SvPVX(PL_linestr) != old_pvx)
    croak("PL_linestr reallocated during scan_str, "
      "Devel::Declare can't continue");
  if (!s)
    return 0;
  if (s <= base_s || memcmp(SvPVX(line_copy), SvPVX(PL_linestr), offset)) {
    s += SvCUR(line_copy);
    sv_catsv(line_copy, PL_linestr);
    dd_set_linestr(aTHX_ SvPV_nolen(line_copy));
  }
  return s - base_s;
}

int dd_toke_skipspace(pTHX_ int offset) {
  char* old_pvx = SvPVX(PL_linestr);
  char* base_s = SvPVX(PL_linestr) + offset;
  char* s = skipspace_force(base_s);
  if(SvPVX(PL_linestr) != old_pvx)
    croak("PL_linestr reallocated during skipspace, "
      "Devel::Declare can't continue");
  return s - base_s;
}

static void call_done_declare(pTHX) {
  dSP;

  if (DD_DEBUG_TRACE) {
    printf("Deconstructing declare\n");
    printf("PL_bufptr: %s\n", PL_bufptr);
    printf("bufend at: %i\n", PL_bufend - PL_bufptr);
    printf("linestr: %s\n", SvPVX(PL_linestr));
    printf("linestr len: %i\n", PL_bufend - SvPVX(PL_linestr));
  }

  ENTER;
  SAVETMPS;

  PUSHMARK(SP);

  call_pv("Devel::Declare::done_declare", G_VOID|G_DISCARD);

  FREETMPS;
  LEAVE;

  if (DD_DEBUG_TRACE) {
    printf("PL_bufptr: %s\n", PL_bufptr);
    printf("bufend at: %i\n", PL_bufend - PL_bufptr);
    printf("linestr: %s\n", SvPVX(PL_linestr));
    printf("linestr len: %i\n", PL_bufend - SvPVX(PL_linestr));
    printf("actual len: %i\n", strlen(PL_bufptr));
  }
}

static int dd_handle_const(pTHX_ char *name);

/* replacement PL_check rv2cv entry */

STATIC OP *dd_ck_rv2cv(pTHX_ OP *o, void *user_data) {
  OP* kid;
  int dd_flags;

  PERL_UNUSED_VAR(user_data);

  if (!DD_AM_LEXING)
    return o; /* not lexing? */

  if (in_declare) {
    call_done_declare(aTHX);
    return o;
  }

  kid = cUNOPo->op_first;

  if (kid->op_type != OP_GV) /* not a GV so ignore */
    return o;

  if (DD_DEBUG_TRACE) {
    printf("Checking GV %s -> %s\n", HvNAME(GvSTASH(kGVOP_gv)), GvNAME(kGVOP_gv));
  }

  dd_flags = dd_is_declarator(aTHX_ GvNAME(kGVOP_gv));

  if (dd_flags == -1)
    return o;

  if (DD_DEBUG_TRACE) {
    printf("dd_flags are: %i\n", dd_flags);
    printf("PL_tokenbuf: %s\n", PL_tokenbuf);
  }

#if DD_CONST_VIA_RV2CV
  if (PL_expect != XOPERATOR) {
    if (!dd_handle_const(aTHX_ GvNAME(kGVOP_gv)))
      return o;
    CopLINE(PL_curcop) = PL_copline;
    /* The parser behaviour that we're simulating depends on what comes
       after the declarator. */
    if (*skipspace(PL_bufptr + strlen(GvNAME(kGVOP_gv))) != '(') {
      if (in_declare) {
        call_done_declare(aTHX);
      } else {
        dd_linestr_callback(aTHX_ "rv2cv", GvNAME(kGVOP_gv));
      }
    }
    return o;
  }
#endif /* DD_CONST_VIA_RV2CV */

  dd_linestr_callback(aTHX_ "rv2cv", GvNAME(kGVOP_gv));

  return o;
}

#if DD_GROW_VIA_BLOCKHOOK

static void dd_block_start(pTHX_ int full)
{
  PERL_UNUSED_VAR(full);
  if (SvLEN(PL_linestr) < DD_PREFERRED_LINESTR_SIZE)
    (void) lex_grow_linestr(DD_PREFERRED_LINESTR_SIZE);
}

#else /* !DD_GROW_VIA_BLOCKHOOK */

OP* dd_pp_entereval(pTHX) {
  dSP;
  STRLEN len;
  const char* s;
  SV *sv;
#ifdef PERL_5_9_PLUS
  SV *saved_hh = NULL;
  if (PL_op->op_private & OPpEVAL_HAS_HH) {
    saved_hh = POPs;
  }
#endif
  sv = POPs;
  if (SvPOK(sv)) {
    if (DD_DEBUG_TRACE) {
      printf("mangling eval sv\n");
    }
    if (SvREADONLY(sv))
      sv = sv_2mortal(newSVsv(sv));
    s = SvPVX(sv);
    len = SvCUR(sv);
    if (!len || s[len-1] != ';') {
      if (!(SvFLAGS(sv) & SVs_TEMP))
        sv = sv_2mortal(newSVsv(sv));
      sv_catpvn(sv, "\n;", 2);
    }
    SvGROW(sv, DD_PREFERRED_LINESTR_SIZE);
  }
  PUSHs(sv);
#ifdef PERL_5_9_PLUS
  if (PL_op->op_private & OPpEVAL_HAS_HH) {
    PUSHs(saved_hh);
  }
#endif
  return PL_ppaddr[OP_ENTEREVAL](aTHX);
}

STATIC OP *dd_ck_entereval(pTHX_ OP *o, void *user_data) {
  PERL_UNUSED_VAR(user_data);

  if (o->op_ppaddr == PL_ppaddr[OP_ENTEREVAL])
    o->op_ppaddr = dd_pp_entereval;
  return o;
}

#endif /* !DD_GROW_VIA_BLOCKHOOK */

static I32 dd_filter_realloc(pTHX_ int idx, SV *sv, int maxlen)
{
  SV *filter_datasv;
  const I32 count = FILTER_READ(idx+1, sv, maxlen);
  SvGROW(sv, DD_PREFERRED_LINESTR_SIZE);
  /* Filters can only be deleted in the correct order (reverse of the
     order in which they were added).  Insisting on deleting the filter
     here would break if another filter were added after ours and is
     still around.  Not deleting the filter at all would break if another
     filter were added earlier and attempts to delete itself later.
     We can play nicely to the maximum possible extent by deleting our
     filter iff it is currently deletable (i.e., it is on the top of
     the filter stack).  Can still run into trouble in more complex
     situations, but can't avoid that. */
  if (PL_rsfp_filters && AvFILLp(PL_rsfp_filters) >= 0 &&
      (filter_datasv = FILTER_DATA(AvFILLp(PL_rsfp_filters))) &&
      IoANY(filter_datasv) == FPTR2DPTR(void *, dd_filter_realloc)) {
    filter_del(dd_filter_realloc);
  }
  return count;
}

static int dd_handle_const(pTHX_ char *name) {
  switch (PL_lex_inwhat) {
    case OP_QR:
    case OP_MATCH:
    case OP_SUBST:
    case OP_TRANS:
    case OP_BACKTICK:
    case OP_STRINGIFY:
      return 0;
      break;
    default:
      break;
  }

  if (strnEQ(PL_bufptr, "->", 2)) {
    return 0;
  }

  {
    char buf[256];
    STRLEN len;
    char *s = PL_bufptr;
    STRLEN old_offset = PL_bufptr - SvPVX(PL_linestr);

    s = scan_word(s, buf, sizeof buf, FALSE, &len);
    if (strnEQ(buf, name, len)) {
      char *d;
      SV *inject = newSVpvn(SvPVX(PL_linestr), PL_bufptr - SvPVX(PL_linestr));
      sv_catpvn(inject, buf, len);

      d = peekspace(s);
      sv_catpvn(inject, s, d - s);

      if ((PL_bufend - d) >= 2 && strnEQ(d, "=>", 2)) {
        return 0;
      }

      sv_catpv(inject, d);
      dd_set_linestr(aTHX_ SvPV_nolen(inject));
      PL_bufptr = SvPVX(PL_linestr) + old_offset;
      SvREFCNT_dec (inject);
    }
  }

  dd_linestr_callback(aTHX_ "const", name);

  return 1;
}

#if !DD_CONST_VIA_RV2CV

STATIC OP *dd_ck_const(pTHX_ OP *o, void *user_data) {
  int dd_flags;
  char* name;

  PERL_UNUSED_VAR(user_data);

  if (DD_HAVE_PARSER && PL_expect == XOPERATOR) {
    return o;
  }

  /* if this is set, we just grabbed a delimited string or something,
     not a bareword, so NO TOUCHY */

  if (DD_HAVE_LEX_STUFF)
    return o;

  /* don't try and look this up if it's not a string const */
  if (!SvPOK(cSVOPo->op_sv))
    return o;

  name = SvPVX(cSVOPo->op_sv);

  dd_flags = dd_is_declarator(aTHX_ name);

  if (dd_flags == -1)
    return o;

  dd_handle_const(aTHX_ name);

  return o;
}

#endif /* !DD_CONST_VIA_RV2CV */

STATIC void dd_initialize(pTHX) {
  static int initialized = 0;
  if (!initialized) {
    initialized = 1;
#if DD_GROW_VIA_BLOCKHOOK
    {
      static BHK bhk;
#if PERL_VERSION_GE(5,13,6)
      BhkENTRY_set(&bhk, bhk_start, dd_block_start);
#else /* <5.13.6 */
      BhkENTRY_set(&bhk, start, dd_block_start);
#endif /* <5.13.6 */
      Perl_blockhook_register(aTHX_ &bhk);
    }
#else /* !DD_GROW_VIA_BLOCKHOOK */
    hook_op_check(OP_ENTEREVAL, dd_ck_entereval, NULL);
#endif /* !DD_GROW_VIA_BLOCKHOOK */
    hook_op_check(OP_RV2CV, dd_ck_rv2cv, NULL);
#if !DD_CONST_VIA_RV2CV
    hook_op_check(OP_CONST, dd_ck_const, NULL);
#endif /* !DD_CONST_VIA_RV2CV */
  }
}

#line 542 "Declare.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

/* Starting from 5.15.2, XS(name) defines a static function (==internal)
 * and the XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 602 "Declare.c"

XS(XS_Devel__Declare_initialize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_initialize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 539 "Declare.xs"
    dd_initialize(aTHX);
#line 617 "Declare.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Devel__Declare_setup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_setup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 544 "Declare.xs"
    dd_initialize(aTHX);
    filter_add(dd_filter_realloc, NULL);
#line 637 "Declare.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Devel__Declare_get_linestr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_get_linestr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;
#line 550 "Declare.xs"
    RETVAL = dd_get_linestr(aTHX);
#line 658 "Declare.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_set_linestr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_set_linestr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "new_value");
    {
	char*	new_value = (char *)SvPV_nolen(ST(0))
;
#line 557 "Declare.xs"
    dd_set_linestr(aTHX_ new_value);
#line 680 "Declare.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Devel__Declare_get_lex_stuff); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_get_lex_stuff)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;
#line 562 "Declare.xs"
    RETVAL = dd_get_lex_stuff(aTHX);
#line 701 "Declare.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_clear_lex_stuff); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_clear_lex_stuff)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 569 "Declare.xs"
    dd_clear_lex_stuff(aTHX);
#line 721 "Declare.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Devel__Declare_get_curstash_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_get_curstash_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;
#line 574 "Declare.xs"
    RETVAL = dd_get_curstash_name(aTHX);
#line 742 "Declare.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_get_linestr_offset); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_get_linestr_offset)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 581 "Declare.xs"
    RETVAL = dd_get_linestr_offset(aTHX);
#line 764 "Declare.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_toke_scan_word); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_toke_scan_word)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "offset, handle_package");
    {
	int	RETVAL;
	dXSTARG;
	int	offset = (int)SvIV(ST(0))
;
	int	handle_package = (int)SvIV(ST(1))
;
#line 588 "Declare.xs"
    RETVAL = dd_toke_scan_word(aTHX_ offset, handle_package);
#line 790 "Declare.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_toke_move_past_token); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_toke_move_past_token)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "offset");
    {
	int	RETVAL;
	dXSTARG;
	int	offset = (int)SvIV(ST(0))
;
#line 595 "Declare.xs"
    RETVAL = dd_toke_move_past_token(aTHX_ offset);
#line 814 "Declare.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_toke_scan_str); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_toke_scan_str)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "offset");
    {
#line 602 "Declare.xs"
    int len;
#line 834 "Declare.c"
	SV *	RETVAL;
	int	offset = (int)SvIV(ST(0))
;
#line 604 "Declare.xs"
    len = dd_toke_scan_str(aTHX_ offset);
    RETVAL = len ? newSViv(len) : &PL_sv_undef;
#line 841 "Declare.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_toke_scan_ident); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_toke_scan_ident)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "offset");
    {
	int	RETVAL;
	dXSTARG;
	int	offset = (int)SvIV(ST(0))
;
#line 612 "Declare.xs"
    RETVAL = dd_toke_scan_ident(aTHX_ offset);
#line 866 "Declare.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_toke_skipspace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_toke_skipspace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "offset");
    {
	int	RETVAL;
	dXSTARG;
	int	offset = (int)SvIV(ST(0))
;
#line 619 "Declare.xs"
    RETVAL = dd_toke_skipspace(aTHX_ offset);
#line 890 "Declare.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_get_in_declare); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_get_in_declare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;
#line 626 "Declare.xs"
    RETVAL = in_declare;
#line 912 "Declare.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Devel__Declare_set_in_declare); /* prototype to pass -Wmissing-prototypes */
XS(XS_Devel__Declare_set_in_declare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "value");
    {
	int	value = (int)SvIV(ST(0))
;
#line 633 "Declare.xs"
    in_declare = value;
#line 934 "Declare.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Devel__Declare); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Devel__Declare)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("Devel::Declare::initialize", XS_Devel__Declare_initialize, file);
        newXS("Devel::Declare::setup", XS_Devel__Declare_setup, file);
        newXS("Devel::Declare::get_linestr", XS_Devel__Declare_get_linestr, file);
        newXS("Devel::Declare::set_linestr", XS_Devel__Declare_set_linestr, file);
        newXS("Devel::Declare::get_lex_stuff", XS_Devel__Declare_get_lex_stuff, file);
        newXS("Devel::Declare::clear_lex_stuff", XS_Devel__Declare_clear_lex_stuff, file);
        newXS("Devel::Declare::get_curstash_name", XS_Devel__Declare_get_curstash_name, file);
        newXS("Devel::Declare::get_linestr_offset", XS_Devel__Declare_get_linestr_offset, file);
        newXS("Devel::Declare::toke_scan_word", XS_Devel__Declare_toke_scan_word, file);
        newXS("Devel::Declare::toke_move_past_token", XS_Devel__Declare_toke_move_past_token, file);
        newXS("Devel::Declare::toke_scan_str", XS_Devel__Declare_toke_scan_str, file);
        newXS("Devel::Declare::toke_scan_ident", XS_Devel__Declare_toke_scan_ident, file);
        newXS("Devel::Declare::toke_skipspace", XS_Devel__Declare_toke_skipspace, file);
        newXS("Devel::Declare::get_in_declare", XS_Devel__Declare_get_in_declare, file);
        newXS("Devel::Declare::set_in_declare", XS_Devel__Declare_set_in_declare, file);

    /* Initialisation Section */

#line 636 "Declare.xs"
{
  char *endptr;
  char *debug_str = getenv ("DD_DEBUG");
  if (debug_str) {
    dd_debug = strtol (debug_str, &endptr, 10);
    if (*endptr != '\0') {
      dd_debug = 0;
    }
  }
}

#line 993 "Declare.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

