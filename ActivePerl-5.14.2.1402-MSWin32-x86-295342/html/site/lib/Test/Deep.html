<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title>Test::Deep - Extremely flexible deep comparison</title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',3);</script>
<h1><a>Test::Deep - Extremely flexible deep comparison</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#examples">EXAMPLES</a></li>
	<ul>

		<li><a href="#without_test__deep">Without Test::Deep</a></li>
		<li><a href="#with_test__deep">With Test::Deep</a></li>
		<li><a href="#reusing_structures">Reusing structures</a></li>
		<li><a href="#circular_data_structures">Circular data structures</a></li>
	</ul>

	<li><a href="#terminology">TERMINOLOGY</a></li>
	<li><a href="#comparison_functions">COMPARISON FUNCTIONS</a></li>
	<ul>

		<ul>

			<li><a href="#_ok___cmp_deeply__got___expected___name_">$ok = cmp_deeply($got, $expected, $name)</a></li>
			<li><a href="#_ok___cmp_bag___got____bag___name_">$ok = cmp_bag(\@got, \@bag, $name)</a></li>
			<li><a href="#_ok___cmp_set___got____set___name_">$ok = cmp_set(\@got, \@set, $name)</a></li>
			<li><a href="#_ok___cmp_methods___got____methods___name_">$ok = cmp_methods(\@got, \@methods, $name)</a></li>
			<li><a href="#_ok___eq_deeply__got___expected_">$ok = eq_deeply($got, $expected)</a></li>
			<li><a href="#__ok___stack____cmp_details__got___expected_">($ok, $stack) = cmp_details($got, $expected)</a></li>
		</ul>

	</ul>

	<li><a href="#special_comparisons_provided">SPECIAL COMPARISONS PROVIDED</a></li>
	<ul>

		<ul>

			<li><a href="#ignore__"><code>ignore()</code></a></li>
			<li><a href="#methods__hash_"><code>methods(%hash)</code></a></li>
			<li><a href="#listmethods__hash_"><code>listmethods(%hash)</code></a></li>
			<li><a href="#shallow__thing_"><code>shallow($thing)</code></a></li>
			<li><a href="#noclass__thing_"><code>noclass($thing)</code></a></li>
			<li><a href="#useclass__thing_"><code>useclass($thing)</code></a></li>
			<li><a href="#re__regexp___capture_data___flags_">re($regexp, $capture_data, $flags)</a></li>
			<li><a href="#superhashof___hash_"><code>superhashof(\%hash)</code></a></li>
			<li><a href="#subhashof___hash_"><code>subhashof(\%hash)</code></a></li>
			<li><a href="#bag__elements_"><code>bag(@elements)</code></a></li>
			<li><a href="#set__elements_"><code>set(@elements)</code></a></li>
			<li><a href="#superbagof__elements___subbagof__elements___supersetof__elements__and_subsetof__elements_"><code>superbagof(@elements)</code>, <code>subbagof(@elements)</code>, <code>supersetof(@elements)</code> and <code>subsetof(@elements)</code></a></li>
			<li><a href="#all__expecteds_"><code>all(@expecteds)</code></a></li>
			<li><a href="#any__expecteds_"><code>any(@expecteds)</code></a></li>
			<li><a href="#isa__class___isa__class_"><code>isa($class)</code>, <code>Isa($class)</code></a></li>
			<li><a href="#array_each__thing_"><code>array_each($thing)</code></a></li>
			<li><a href="#str__string_"><code>str($string)</code></a></li>
			<li><a href="#num__number___tolerance_">num($number, $tolerance)</a></li>
			<li><a href="#bool__value_"><code>bool($value)</code></a></li>
			<li><a href="#code___subref_">code(\&amp;subref)</a></li>
		</ul>

	</ul>

	<li><a href="#diagnostic_functions">DIAGNOSTIC FUNCTIONS</a></li>
	<ul>

		<ul>

			<li><a href="#my__reason___deep_diag__stack_">my $reason = <code>deep_diag($stack)</code></a></li>
		</ul>

	</ul>

	<li><a href="#another_example">ANOTHER EXAMPLE</a></li>
	<li><a href="#using_test__deep_with_test__builder">USING TEST::DEEP WITH TEST::BUILDER</a></li>
	<li><a href="#limitations">LIMITATIONS</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#what_are_special_comparisons">WHAT ARE SPECIAL COMPARISONS?</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#maintainer">MAINTAINER</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Test::Deep - Extremely flexible deep comparison</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  <span class="keyword">use</span> <span class="variable">Test::More</span> <span class="string">tests</span> <span class="operator">=&gt;</span> <span class="variable">$Num_Tests</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">Test::Deep</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$actual_horrible_nested_data_structure</span><span class="operator">,</span>
    <span class="variable">$expected_horrible_nested_data_structure</span><span class="operator">,</span>
    <span class="string">"got the right horrible nested data structure"</span>
  <span class="operator">);</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$object</span><span class="operator">,</span>
    <span class="variable">methods</span><span class="operator">(</span><span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">"John"</span><span class="operator">,</span> <span class="string">phone</span> <span class="operator">=&gt;</span> <span class="string">"55378008"</span><span class="operator">),</span>
    <span class="string">"object methods ok"</span>
  <span class="operator">);</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="operator">\</span><span class="variable">@array</span><span class="operator">,</span>
    <span class="operator">[</span><span class="variable">$hash1</span><span class="operator">,</span> <span class="variable">$hash2</span><span class="operator">,</span> <span class="variable">ignore</span><span class="operator">()</span><span class="operator">]</span><span class="operator">,</span>
    <span class="string">"first 2 elements are as expected, ignoring 3"</span>
  <span class="operator">);</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$object</span><span class="operator">,</span>
    <span class="variable">noclass</span><span class="operator">(</span><span class="operator">{</span><span class="string">value</span> <span class="operator">=&gt;</span> <span class="number">5</span><span class="operator">}</span><span class="operator">),</span>
    <span class="string">"object looks ok, not checking it's class"</span>
  <span class="operator">);</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="operator">\</span><span class="variable">@result</span><span class="operator">,</span>
    <span class="variable">bag</span><span class="operator">(</span><span class="string">'a'</span><span class="operator">,</span> <span class="string">'b'</span><span class="operator">,</span> <span class="operator">{</span><span class="string">key</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">]}</span><span class="operator">),</span>
    <span class="string">"array has the 3 things we wanted in some order"</span>
  <span class="operator">);</span>
</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>If you don't know anything about automated testing in Perl then you should
probably read about Test::Simple and Test::More before preceding.
Test::Deep uses the Test::Builder framework.</p>
<p>Test::Deep gives you very flexible ways to check that the result you got is
the result you were expecting. At it's simplest it compares two structures
by going through each level, ensuring that the values match, that arrays and
hashes have the same elements and that references are blessed into the
correct class. It also handles circular data structures without getting
caught in an infinite loop.</p>
<p>Where it becomes more interesting is in allowing you to do something besides
simple exact comparisons. With strings, the <code>eq</code> operator checks that 2
strings are exactly equal but sometimes that's not what you want. When you
don't know exactly what the string should be but you do know some things
about how it should look, <code>eq</code> is no good and you must use pattern matching
instead. Test::Deep provides pattern matching for complex data structures</p>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<p>How Test::Deep works is much easier to understand by seeing some examples.</p>
<p>
</p>
<h2><a name="without_test__deep">Without Test::Deep</a></h2>
<p>Say you want to test a function which returns a string. You know that your
string should be a 7 digit number beginning with 0, <code>eq</code> is no good in this
situation, you need a regular expression. So you could use Test::More's
<code>like()</code> function:</p>
<pre>
  <span class="variable">like</span><span class="operator">(</span><span class="variable">$string</span><span class="operator">,</span> <span class="string">'/^0d{6}$/'</span><span class="operator">,</span> <span class="string">"number looks good"</span><span class="operator">);</span>
</pre>
<p>Similarly, to check that a string looks like a name, you could do:</p>
<pre>
  <span class="variable">like</span><span class="operator">(</span><span class="variable">$string</span><span class="operator">,</span> <span class="string">'/^(Mr|Mrs|Miss) \w+ \w+$/'</span><span class="operator">,</span>
    <span class="string">"got title, first and last name"</span><span class="operator">);</span>
</pre>
<p>Now imagine your function produces a hash with some personal details in it.
You want to make sure that there are 2 keys, Name and Phone and that the
name looks like a name and the phone number looks like a phone number. You
could do:</p>
<pre>
  <span class="variable">$hash</span> <span class="operator">=</span> <span class="variable">make_person</span><span class="operator">();</span>
  <span class="variable">like</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Name</span><span class="operator">}</span><span class="operator">,</span> <span class="string">'/^(Mr|Mrs|Miss) \w+ \w+$/'</span><span class="operator">,</span> <span class="string">"name ok"</span><span class="operator">);</span>
  <span class="variable">like</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Phone</span><span class="operator">}</span><span class="operator">,</span> <span class="string">'/^0d{6}$/'</span><span class="operator">,</span> <span class="string">"phone ok"</span><span class="operator">);</span>
  <span class="variable">is</span><span class="operator">(</span><span class="keyword">scalar</span> <span class="keyword">keys</span> <span class="variable">%$hash</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="string">"correct number of keys"</span><span class="operator">);</span>
</pre>
<p>But that's not quite right, what if make_person has a serious problem and
didn't even return a hash? We really need to write</p>
<pre>
  <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">ref</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">)</span> <span class="keyword">eq</span> <span class="string">"HASH"</span><span class="operator">)</span>
  <span class="operator">{</span>
    <span class="variable">like</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Name</span><span class="operator">}</span><span class="operator">,</span> <span class="string">'/^(Mr|Mrs|Miss) \w+ \w+$/'</span><span class="operator">,</span> <span class="string">"name ok"</span><span class="operator">);</span>
    <span class="variable">like</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Phone</span><span class="operator">}</span><span class="operator">,</span> <span class="string">'/^0d{6}$/'</span><span class="operator">,</span> <span class="string">"phone ok"</span><span class="operator">);</span>
    <span class="variable">is</span><span class="operator">(</span><span class="keyword">scalar</span> <span class="keyword">keys</span> <span class="variable">%$hash</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="string">"correct number of keys"</span><span class="operator">);</span>
  <span class="operator">}</span>
  <span class="keyword">else</span>
  <span class="operator">{</span>
    <span class="variable">fail</span><span class="operator">(</span><span class="string">"person not a hash"</span><span class="operator">);</span>
    <span class="variable">fail</span><span class="operator">(</span><span class="string">"person not a hash"</span><span class="operator">);</span>
    <span class="variable">fail</span><span class="operator">(</span><span class="string">"person not a hash"</span><span class="operator">);</span> <span class="comment"># need 3 to keep the plan correct</span>
  <span class="operator">}</span>
</pre>
<p>Already this is getting messy, now imagine another entry in the hash, an
array of children's names. This would require</p>
<pre>
  <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">ref</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">)</span> <span class="keyword">eq</span> <span class="string">"HASH"</span><span class="operator">)</span>
  <span class="operator">{</span>
    <span class="variable">like</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Name</span><span class="operator">}</span><span class="operator">,</span> <span class="variable">$name_pat</span><span class="operator">,</span> <span class="string">"name ok"</span><span class="operator">);</span>
    <span class="variable">like</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Phone</span><span class="operator">}</span><span class="operator">,</span> <span class="string">'/^0d{6}$/'</span><span class="operator">,</span> <span class="string">"phone ok"</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$cn</span> <span class="operator">=</span> <span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ChildNames</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">ref</span><span class="operator">(</span><span class="variable">$cn</span><span class="operator">)</span> <span class="keyword">eq</span> <span class="string">"ARRAY"</span><span class="operator">)</span>
    <span class="operator">{</span>
      <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$child</span> <span class="operator">(</span><span class="variable">@$cn</span><span class="operator">)</span>
      <span class="operator">{</span>
        <span class="variable">like</span><span class="operator">(</span><span class="variable">$child</span><span class="operator">,</span> <span class="variable">$name_pat</span><span class="operator">);</span>
      <span class="operator">}</span>
    <span class="operator">}</span>
    <span class="keyword">else</span>
    <span class="operator">{</span>
        <span class="variable">fail</span><span class="operator">(</span><span class="string">"child names not an array"</span><span class="operator">)</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
  <span class="keyword">else</span>
  <span class="operator">{</span>
    <span class="variable">fail</span><span class="operator">(</span><span class="string">"person not a hash"</span><span class="operator">);</span>
  <span class="operator">}</span>
</pre>
<p>This is a horrible mess and because we don't know in advance how many
children's names there will be, we can't make a plan for our test anymore
(actually, we could but it would make things even more complicated).</p>
<p>Test::Deep to the rescue.</p>
<p>
</p>
<h2><a name="with_test__deep">With Test::Deep</a></h2>
<pre>
  <span class="keyword">my</span> <span class="variable">$name_re</span> <span class="operator">=</span> <span class="variable">re</span><span class="operator">(</span><span class="string">'^(Mr|Mrs|Miss) \w+ \w+$'</span><span class="operator">);</span>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$person</span><span class="operator">,</span>
    <span class="operator">{</span>
      <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="variable">$name_re</span><span class="operator">,</span>
      <span class="string">Phone</span> <span class="operator">=&gt;</span> <span class="variable">re</span><span class="operator">(</span><span class="string">'^0d{6}$'</span><span class="operator">),</span>
      <span class="string">ChildNames</span> <span class="operator">=&gt;</span> <span class="variable">array_each</span><span class="operator">(</span><span class="variable">$name_re</span><span class="operator">)</span>
    <span class="operator">}</span><span class="operator">,</span>
    <span class="string">"person ok"</span>
  <span class="operator">);</span>
</pre>
<p>This will do everything that the messy code above does and it will give a
sensible message telling you exactly what went wrong if it finds a part of
$person that doesn't match the pattern. <code>re()</code> and <code>array_each()</code> are
special function imported from Test::Deep. They create a marker that tells
Test::Deep that something different is happening here. Instead of just doing
a simple comparison and checking are two things exactly equal, it should do
something else.</p>
<p>If a person was asked to check that 2 structures are equal, they could print
them both out and compare them line by line. The markers above are similar
to writing a note in red pen on one of the printouts telling the person that
for this piece of the structure, they should stop doing simple line by line
comparison and do something else.</p>
<p><code>re($regex)</code> means that Test::Deep should check that the current piece of
data matches the regex in <code>$regex</code>. <code>array_each($struct)</code> means that
Test::Deep should expect the current piece of data to be an array and it
should check that every element of that array matches <code>$struct</code>.
In this case, every element of <code>$person-&gt;{ChildNames}</code> should look like a
name. If say the 3rd one didn't you would get an error message something
like</p>
<pre>
  <span class="variable">Using</span> <span class="variable">Regexp</span> <span class="variable">on</span> <span class="variable">$data</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ChildNames</span><span class="operator">}[</span><span class="number">3</span><span class="operator">]</span>
     <span class="variable">got</span>    <span class="operator">:</span> <span class="string">'Queen John Paul Sartre'</span>
     <span class="variable">expect</span> <span class="operator">:</span> <span class="regex">/^(Mr|Mrs|Miss) \w+ \w+$/</span>
</pre>
<p>There are lots of other special comparisons available, see
<a href="#special_comparisons_provided">SPECIAL COMPARISONS PROVIDED</a> below for the full list.</p>
<p>
</p>
<h2><a name="reusing_structures">Reusing structures</a></h2>
<p>Test::Deep is good for reusing test structures so you can do this</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$name_re</span> <span class="operator">=</span> <span class="variable">re</span><span class="operator">(</span><span class="string">'^(Mr|Mrs|Miss) \w+ \w+$'</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$person_cmp</span> <span class="operator">=</span> <span class="operator">{</span>
    <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="variable">$name_re</span><span class="operator">,</span>
    <span class="string">Phone</span> <span class="operator">=&gt;</span> <span class="variable">re</span><span class="operator">(</span><span class="string">'^0d{6}$'</span><span class="operator">),</span>
    <span class="string">ChildNames</span> <span class="operator">=&gt;</span> <span class="variable">array_each</span><span class="operator">(</span><span class="variable">$name_re</span><span class="operator">)</span>
  <span class="operator">}</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$person1</span><span class="operator">,</span> <span class="variable">$person_cmp</span><span class="operator">,</span> <span class="string">"person ok"</span><span class="operator">);</span>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$person2</span><span class="operator">,</span> <span class="variable">$person_cmp</span><span class="operator">,</span> <span class="string">"person ok"</span><span class="operator">);</span>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$person3</span><span class="operator">,</span> <span class="variable">$person_cmp</span><span class="operator">,</span> <span class="string">"person ok"</span><span class="operator">);</span>
</pre>
<p>You can even put $person_cmp in a module and let other people use it when
they are writing test scripts for modules that use your modules.</p>
<p>To make things a little more difficult, lets change the person data
structure so that instead of a list of ChildNames, it contains a list of
hashes, one for each child. So in fact our person structure will contain
other person structures which may contain other person structures and so on.
This is easy to handle with Test::Deep because Test::Deep structures can
include themselves. Simply do</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$name_re</span> <span class="operator">=</span> <span class="variable">re</span><span class="operator">(</span><span class="string">'^(Mr|Mrs|Miss) \w+ \w+$'</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$person_cmp</span> <span class="operator">=</span> <span class="operator">{</span>
    <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="variable">$name_re</span><span class="operator">,</span>
    <span class="string">Phone</span> <span class="operator">=&gt;</span> <span class="variable">re</span><span class="operator">(</span><span class="string">'^0d{6}$'</span><span class="operator">),</span>
    <span class="comment"># note no mention of Children here</span>
  <span class="operator">}</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$person_cmp</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Children</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">each_array</span><span class="operator">(</span><span class="variable">$person_cmp</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$person</span><span class="operator">,</span> <span class="variable">$person_cmp</span><span class="operator">,</span> <span class="string">"person ok"</span><span class="operator">);</span>
</pre>
<p>This will now check that $person-&gt;{Children} is an array and that every
element of that array also matches <code>$person_cmp</code>, this includes checking
that it's children also match the same pattern and so on.</p>
<p>
</p>
<h2><a name="circular_data_structures">Circular data structures</a></h2>
<p>A circular data structure is one which loops back on itself, you can make
one easily by doing</p>
<pre>
  <span class="keyword">my</span> <span class="variable">@b</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@b</span><span class="operator">);</span>
  <span class="keyword">push</span><span class="operator">(</span><span class="variable">@b</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@a</span><span class="operator">);</span>
</pre>
<p>now @a contains a reference to be @b and @b contains a reference to @a. This
causes problems if you have a program that wants to look inside @a and keep
looking deeper and deeper at every level, it could get caught in an infinite
loop looking into @a then @b then @a then @b and so on.</p>
<p>Test::Deep avoids this problem so we can extend our example further by
saying that a person should also list their parents.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$name_re</span> <span class="operator">=</span> <span class="variable">re</span><span class="operator">(</span><span class="string">'^(Mr|Mrs|Miss) \w+ \w+$'</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$person_cmp</span> <span class="operator">=</span> <span class="operator">{</span>
    <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="variable">$name_re</span><span class="operator">,</span>
    <span class="string">Phone</span> <span class="operator">=&gt;</span> <span class="variable">re</span><span class="operator">(</span><span class="string">'^0d{6}$'</span><span class="operator">),</span>
    <span class="comment"># note no mention of Children here</span>
  <span class="operator">}</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$person_cmp</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Children</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">each_array</span><span class="operator">(</span><span class="variable">$person_cmp</span><span class="operator">);</span>
  <span class="variable">$person_cmp</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Parents</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">each_array</span><span class="operator">(</span><span class="variable">$person_cmp</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$person</span><span class="operator">,</span> <span class="variable">$person_cmp</span><span class="operator">,</span> <span class="string">"person ok"</span><span class="operator">);</span>
</pre>
<p>So this will check that for each child <code>$child</code> in <code>$person-&gt;{Children}</code>
that the <code>$child-&gt;{Parents}</code> matches <code>$person_cmp</code> however it is smart
enough not to get caught in an infinite loop where it keeps bouncing between
the same Parent and Child.</p>
<p>
</p>
<hr />
<h1><a name="terminology">TERMINOLOGY</a></h1>
<p><code>cmp_deeply($got, $expected, $name)</code> takes 3 arguments. <code>$got</code> is the
structure that you are checking, you must not include any special
comparisons in this structure or you will get a fatal error. <code>$expected</code>
describes what Test::Deep will be looking for in $got. You can put special
comparisons in $expected if you want to.</p>
<p>As Test::Deep descends through the 2 structures, it compares them one piece
at a time, so at any point in the process, Test::Deep is thinking about 2
things - the current value from <code>$got</code> and the current value from
<code>$expected</code>. In the documentation, I call them <code>$got_v</code> and <code>exp_v</code>
respectively.</p>
<p>
</p>
<hr />
<h1><a name="comparison_functions">COMPARISON FUNCTIONS</a></h1>
<p>
</p>
<h3><a name="_ok___cmp_deeply__got___expected___name_">$ok = cmp_deeply($got, $expected, $name)</a></h3>
<p>$got is the result to be checked. $expected is the structure against which
$got will be check. $name is the test name.</p>
<p>This is the main comparison function, the others are just wrappers around
this. Without any special comparisons, it will descend into $expected,
following every reference and comparing <code>$expected_v</code> to <code>$got_v</code> (using
<code>eq</code>) at the same position. If at any stage <code>$expected_v</code> is a special
comparison then Test::Deep may do something else besides a simple string
comparison, exactly what it does depends on which special comparison it is.</p>
<p>
</p>
<h3><a name="_ok___cmp_bag___got____bag___name_">$ok = cmp_bag(\@got, \@bag, $name)</a></h3>
<p>Is shorthand for cmp_deeply(\@got, <code>bag(@bag)</code>, $name)</p>
<p>N.B. Both arguments must be array refs. If they aren't an error will
be raised via die.</p>
<p>
</p>
<h3><a name="_ok___cmp_set___got____set___name_">$ok = cmp_set(\@got, \@set, $name)</a></h3>
<p>Is shorthand for cmp_deeply(\@got, <code>set(@set)</code>, $name)</p>
<p>
</p>
<h3><a name="_ok___cmp_methods___got____methods___name_">$ok = cmp_methods(\@got, \@methods, $name)</a></h3>
<p>Is shorthand for cmp_deeply(\@got, <code>methods(@methods)</code>, $name)</p>
<p>
</p>
<h3><a name="_ok___eq_deeply__got___expected_">$ok = eq_deeply($got, $expected)</a></h3>
<p>This is the same as <code>cmp_deeply()</code> except it just returns true or
false. It does not create diagnostics or talk to <a href="../../../lib/Test/Builder.html">the Test::Builder manpage</a>, but
if you want to use it in a non-testing environment then you should
import it through <a href="../../../cpan/build/Test-Deep-0.109-wclwY5/blib/html/site/lib/Test/Deep/NoTest.html">the Test::Deep::NoTest manpage</a>. For example</p>
<pre>
  <span class="keyword">use</span> <span class="variable">Test::Deep::NoTest</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"a equals b"</span> <span class="keyword">unless</span> <span class="variable">eq_deeply</span><span class="operator">(</span><span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">);</span>
</pre>
<p>otherwise the <a href="../../../lib/Test/Builder.html">the Test::Builder manpage</a> framework will be loaded and testing messages
will be output when your program ends.</p>
<p>
</p>
<h3><a name="__ok___stack____cmp_details__got___expected_">($ok, $stack) = cmp_details($got, $expected)</a></h3>
<p>This behaves much like eq_deeply, but it additionally allows you to
produce diagnostics in case of failure by passing the value in <code>$stack</code>
to <code>deep_diag</code>.</p>
<p>Do not make assumptions about the structure or content of <code>$stack</code> and
do not use it if <code>$ok</code> contains a true value.</p>
<p>See <a href="#using_test__deep_with_test__builder">USING TEST::DEEP WITH TEST::BUILDER</a> for example uses.</p>
<p>
</p>
<hr />
<h1><a name="special_comparisons_provided">SPECIAL COMPARISONS PROVIDED</a></h1>
<p>
</p>
<h3><a name="ignore__"><code>ignore()</code></a></h3>
<p>This makes Test::Deep skip tests on $got_v. No matter what value <code>$got_v</code>
has, Test::Deep will think it's correct. This is useful if some part of the
structure you are testing is very complicated and already tested elsewhere,
or is unpredictable.</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$got</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'John'</span><span class="operator">,</span> <span class="string">random</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">(),</span> <span class="string">address</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">'5 A
    street'</span><span class="operator">,</span> <span class="string">'a town'</span><span class="operator">,</span> <span class="string">'a country'</span><span class="operator">]</span><span class="operator">,</span>
  <span class="operator">}</span><span class="operator">)</span>
</pre>
<p>is the equivalent of checking</p>
<pre>
  <span class="variable">$got</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">name</span><span class="operator">}</span> <span class="keyword">eq</span> <span class="string">'John'</span><span class="operator">;</span>
  <span class="keyword">exists</span> <span class="variable">$got</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">random</span><span class="operator">}</span><span class="operator">;</span>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$got</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">address</span><span class="operator">}</span><span class="operator">;</span>
  <span class="operator">[</span><span class="string">'5 A street'</span><span class="operator">,</span> <span class="string">'a town'</span><span class="operator">,</span> <span class="string">'a country'</span><span class="operator">]</span><span class="operator">);</span>
</pre>
<p>
</p>
<h3><a name="methods__hash_"><code>methods(%hash)</code></a></h3>
<p>%hash is a hash of method call =&gt; expected value pairs.</p>
<p>This lets you call methods on an object and check the result of each call.
The methods will be called in the order supplied. If you want to pass
arguments to the method you should wrap the method name and arguments in an
array reference.</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$obj</span><span class="operator">,</span>
    <span class="variable">methods</span><span class="operator">(</span><span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">"John"</span><span class="operator">,</span> <span class="operator">[</span><span class="string">"favourite"</span><span class="operator">,</span> <span class="string">"food"</span><span class="operator">]</span> <span class="operator">=&gt;</span> <span class="string">"taco"</span><span class="operator">)</span>
  <span class="operator">);</span>
</pre>
<p>is roughly the equivalent of checking that</p>
<pre>
  $obj-&gt;name eq &quot;John&quot;
  $obj-&gt;favourite(&quot;food&quot;) eq &quot;taco&quot;</pre>
<p>The methods will be called in the order you supply them and will be called
in scalar context. If you need to test methods called in list context then
you should use <code>listmethods()</code>.</p>
<p><strong>NOTE</strong> Just as in a normal test script, you need to be careful if the
methods you call have side effects like changing the object or other objects
in the structure. Although the order of the methods is fixed, the order of
some other tests is not so if $expected is</p>
<pre>
  <span class="operator">{</span>
    <span class="string">manager</span> <span class="operator">=&gt;</span> <span class="variable">methods</span><span class="operator">(</span><span class="variable">@manager_methods</span><span class="operator">),</span>
    <span class="string">coder</span> <span class="operator">=&gt;</span> <span class="variable">methods</span><span class="operator">(</span><span class="variable">@coder_methods</span><span class="operator">)</span>
  <span class="operator">}</span>
</pre>
<p>there is no way to know which if manager and coder will be tested first. If
the methods you are testing depend on and alter global variables or if
manager and coder are the same object then you may run into problems.</p>
<p>
</p>
<h3><a name="listmethods__hash_"><code>listmethods(%hash)</code></a></h3>
<p>%hash is a hash of method call =&gt; expected value pairs.</p>
<p>This is almost identical to <code>methods()</code> except the methods are called in list
context instead of scalar context. This means that the expected values
supplied must be an array reference.</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$obj</span><span class="operator">,</span>
    <span class="variable">listmethods</span><span class="operator">(</span>
      <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">"John"</span><span class="operator">,</span>
      <span class="operator">[</span><span class="string">"favourites"</span><span class="operator">,</span> <span class="string">"food"</span><span class="operator">]</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">"Mapo tofu"</span><span class="operator">,</span> <span class="string">"Gongbao chicken"</span><span class="operator">]</span>
    <span class="operator">)</span>
  <span class="operator">);</span>
</pre>
<p>is the equivalent of checking that</p>
<pre>
  <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">name</span> <span class="keyword">eq</span> <span class="string">"John"</span>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="operator">[</span><span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">favourites</span><span class="operator">(</span><span class="string">"food"</span><span class="operator">)</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="string">"Mapo tofu"</span><span class="operator">,</span> <span class="string">"Gongbao chicken"</span><span class="operator">]</span><span class="operator">);</span>
</pre>
<p>The methods will be called in the order you supply them.</p>
<p><strong>NOTE</strong> The same caveats apply as for <code>methods()</code>.</p>
<p>
</p>
<h3><a name="shallow__thing_"><code>shallow($thing)</code></a></h3>
<p>$thing is a ref.</p>
<p>This prevents Test::Deep from looking inside $thing. It allows you to
check that $got_v and $thing are references to the same variable. So</p>
<pre>
  <span class="keyword">my</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="variable">@b</span> <span class="operator">=</span> <span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">);</span>
  <span class="variable">cmp_deeply</span><span class="operator">(\</span><span class="variable">@a</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@b</span><span class="operator">);</span>
</pre>
<p>will pass because @a and @b have the same elements however</p>
<pre>
  cmp_deeply(\@a, shallow(\@b))</pre>
<p>will fail because although \@a and \@b both contain <code>1, 2, 3</code> they are
references to different arrays.</p>
<p>
</p>
<h3><a name="noclass__thing_"><code>noclass($thing)</code></a></h3>
<p>$thing is a structure to be compared against.</p>
<p>This makes Test::Deep ignore the class of objects, so it just looks at the
data they contain. Class checking will be turned off until Test::Deep is
finished comparing <code>$got_v</code> against <code>$thing</code>. Once Test::Deep comes out of
<code>$thing</code> it will go back to it's previous setting for checking class.</p>
<p>This can be useful when you want to check that objects have been
constructed correctly but you don't want to write lots of
<a href="../../../lib/pods/perlfunc.html#bless"><code>bless</code></a>es. If \@people is an array of Person objects then</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(\</span><span class="variable">@people</span><span class="operator">,</span> <span class="variable">noclass</span><span class="operator">(</span><span class="operator">[</span>
    <span class="keyword">bless</span> <span class="operator">{</span><span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'John'</span><span class="operator">,</span> <span class="string">phone</span> <span class="operator">=&gt;</span> <span class="string">'555-5555'</span><span class="operator">}</span><span class="operator">,</span> <span class="string">"Person"</span><span class="operator">,</span>
    <span class="keyword">bless</span> <span class="operator">{</span><span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'Anne'</span><span class="operator">,</span> <span class="string">phone</span> <span class="operator">=&gt;</span> <span class="string">'444-4444'</span><span class="operator">}</span><span class="operator">,</span> <span class="string">"Person"</span><span class="operator">,</span>
  <span class="operator">]</span><span class="operator">));</span>
</pre>
<p>can be replaced with</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(\</span><span class="variable">@people</span><span class="operator">,</span> <span class="variable">noclass</span><span class="operator">(</span><span class="operator">[</span>
    <span class="operator">{</span><span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'John'</span><span class="operator">,</span> <span class="string">phone</span> <span class="operator">=&gt;</span> <span class="string">'555-5555'</span><span class="operator">}</span><span class="operator">,</span>
    <span class="operator">{</span><span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'Anne'</span><span class="operator">,</span> <span class="string">phone</span> <span class="operator">=&gt;</span> <span class="string">'444-4444'</span><span class="operator">}</span>
  <span class="operator">]</span><span class="operator">));</span>
</pre>
<p>However, this is testing so you should also check that the objects are
blessed correctly. You could use a map to bless all those hashes or you
could do a second test like</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$people</span><span class="operator">,</span> <span class="variable">array_each</span><span class="operator">(</span><span class="variable">isa</span><span class="operator">(</span><span class="string">"Person"</span><span class="operator">));</span>
</pre>
<p>
</p>
<h3><a name="useclass__thing_"><code>useclass($thing)</code></a></h3>
<p>This turns back on the class comparison while inside a <code>noclass()</code>.</p>
<pre>
  cmp_deeply(
    $got,
    noclass(
      [
        useclass( $object )
      ]
    )
  )</pre>
<p>In this example the class of the array reference in <code>$got</code> is ignored but
the class of <code>$object</code> is checked, as is the class of everything inside
<code>$object</code>.</p>
<p>
</p>
<h3><a name="re__regexp___capture_data___flags_">re($regexp, $capture_data, $flags)</a></h3>
<p>$regexp is either a regular expression reference produced with <a href="../../../lib/pods/perlfunc.html#qr_"><code>qr/.../</code></a> or
a string which will be used to construct a regular expression.</p>
<p>$capture_data is optional and is used to check the strings captured by
an regex. This should can be an array ref or a Test::Deep comparator
that works on array refs.</p>
<p>$flags is an optional string which controls whether the regex runs as a
global match. If $flags is &quot;g&quot; then the regex will run as m/$regexp/g.</p>
<p>Without $capture_data, this simply compares $got_v with the regular expression
provided. So</p>
<pre>
  cmp_deeply($got, [ re(&quot;ferg&quot;) ])</pre>
<p>is the equivalent of</p>
<pre>
  $got-&gt;[0] =~ /ferg/</pre>
<p>With $capture_data</p>
<pre>
  cmp_deeply($got, [re($regex, $capture_data])</pre>
<p>is the equivalent of</p>
<pre>
  <span class="keyword">my</span> <span class="variable">@data</span> <span class="operator">=</span> <span class="variable">$got</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=~</span> <span class="regex">/</span><span class="variable">$regex</span><span class="regex">/</span><span class="operator">;</span>
  <span class="variable">cmp_deeply</span><span class="operator">(\</span><span class="variable">@data</span><span class="operator">,</span> <span class="variable">$capture_data</span><span class="operator">);</span>
</pre>
<p>So you can do something simple like</p>
<pre>
  cmp_deeply($got, re(qr/(\d\d)(\w\w)/, [25, &quot;ab&quot; ])</pre>
<p>to check that (\d\d) was 25 and (\w\w) was &quot;ab&quot; but you can also use
Test::Deep objects to do more complex testing of the captured values</p>
<pre>
  cmp_deeply(&quot;cat=2,dog=67,sheep=3,goat=2,dog=5&quot;,
    re(qr/(\D+)=\d+,?/, set(qw( cat sheep dog )), &quot;g&quot;))</pre>
<p>here, the regex will match the string and will capture the animal names and
check that they match the specified set, in this case it will fail,
complaining that &quot;goat&quot; is not in the set.</p>
<p>
</p>
<h3><a name="superhashof___hash_"><code>superhashof(\%hash)</code></a></h3>
<p>This will check that the hash <code>%$got</code> is a &quot;super-hash&quot; of <code>%hash</code>. That
is that all the key and value pairs in <code>%hash</code> appear in <code>%$got</code> but
<code>%$got</code> can have extra ones also.</p>
<p>For example</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="operator">{</span><span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">b</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">}</span><span class="operator">,</span> <span class="variable">superhashof</span><span class="operator">(</span><span class="operator">{</span><span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span><span class="operator">))</span>
</pre>
<p>will pass but</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="operator">{</span><span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">b</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">}</span><span class="operator">,</span> <span class="variable">superhashof</span><span class="operator">(</span><span class="operator">{</span><span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">c</span> <span class="operator">=&gt;</span> <span class="number">3</span><span class="operator">}</span><span class="operator">))</span>
</pre>
<p>will fail.</p>
<p>
</p>
<h3><a name="subhashof___hash_"><code>subhashof(\%hash)</code></a></h3>
<p>This will check that the hash <code>%$got</code> is a &quot;sub-hash&quot; of <code>%hash</code>. That is
that all the key and value pairs in <code>%$got</code> also appear in <code>%hash</code>.</p>
<p>For example</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="operator">{</span><span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span><span class="operator">,</span> <span class="variable">subhashof</span><span class="operator">(</span><span class="operator">{</span><span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">b</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">}</span><span class="operator">))</span>
</pre>
<p>will pass but</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="operator">{</span><span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">c</span> <span class="operator">=&gt;</span> <span class="number">3</span><span class="operator">}</span><span class="operator">,</span> <span class="variable">subhashof</span><span class="operator">(</span><span class="operator">{</span><span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">b</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">}</span><span class="operator">))</span>
</pre>
<p>will fail.</p>
<p>
</p>
<h3><a name="bag__elements_"><code>bag(@elements)</code></a></h3>
<p>@elements is an array of elements.</p>
<p>This does a bag comparison, that is, it compares two arrays but ignores the
order of the elements so</p>
<pre>
  cmp_deeply([1, 2, 2], bag(2, 2, 1))</pre>
<p>will be a pass.</p>
<p>The object returned by <code>bag()</code> has an <code>add()</code> method.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$bag</span> <span class="operator">=</span> <span class="variable">bag</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">);</span>
  <span class="variable">$bag</span><span class="operator">-&gt;</span><span class="variable">add</span><span class="operator">(</span><span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span><span class="operator">);</span>
</pre>
<p>will result in a bag containing 1, 2, 2, 3, 3, 4.</p>
<p><code>NOTE</code> If you use certain special comparisons within a bag or set
comparison there is a danger that a test will fail when it should have
passed. It can only happen if two or more special comparisons in the bag are
competing to match elements. Consider this comparison</p>
<pre>
  cmp_deeply(['furry', 'furball'], bag(re(&quot;^fur&quot;), re(&quot;furb&quot;)))</pre>
<p>There are two things that could happen, hopefully <code>re(&quot;^fur&quot;)</code> is paired with
&quot;furry&quot; and <code>re(&quot;^furb&quot;)</code> is paired with &quot;furb&quot; and everything is fine but it
could happen that <code>re(&quot;^fur&quot;)</code> is paired with &quot;furball&quot; and then <code>re(&quot;^furb&quot;)</code>
cannot find a match and so the test fails. Examples of other competing
comparisons are <code>bag(1, 2, 2)</code> vs <code>set(1, 2)</code> and
<code>methods(m1 =&gt; &quot;v1&quot;, m2 =&gt; &quot;v2&quot;)</code> vs <code>methods(m1 =&gt; &quot;v1&quot;)</code></p>
<p>This problem is could be solved by using a slower and more complicated
algorithm for set and bag matching. Something for the future...</p>
<p>
</p>
<h3><a name="set__elements_"><code>set(@elements)</code></a></h3>
<p>@elements is an array of elements.</p>
<p>This does a set comparison, that is, it compares two arrays but ignores the
order of the elements and it ignores duplicate elements, so</p>
<pre>
  cmp_deeply([1, 2, 2, 3], set(3, 2, 1, 1))</pre>
<p>will be a pass.</p>
<p>The object returned by <code>set()</code> has an <code>add()</code> method.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$set</span> <span class="operator">=</span> <span class="variable">set</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">);</span>
  <span class="variable">$set</span><span class="operator">-&gt;</span><span class="variable">add</span><span class="operator">(</span><span class="number">4</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="number">6</span><span class="operator">);</span>
</pre>
<p>will result in a set containing 1, 2, 3, 4, 5, 5.</p>
<p><code>NOTE</code> See the NOTE on the <code>bag()</code> comparison for some dangers in using
special comparisons inside <code>set()</code></p>
<p>
</p>
<h3><a name="superbagof__elements___subbagof__elements___supersetof__elements__and_subsetof__elements_"><code>superbagof(@elements)</code>, <code>subbagof(@elements)</code>, <code>supersetof(@elements)</code> and <code>subsetof(@elements)</code></a></h3>
<p>@elements is an array of elements.</p>
<p>These do exactly what you'd expect them to do, so for example</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$data</span><span class="operator">,</span> <span class="variable">subbagof</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="number">4</span><span class="operator">));</span>
</pre>
<p>checks that @$data contains at most 2 &quot;1&quot;s, 1 &quot;3&quot; and 1 &quot;4&quot; and</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$data</span><span class="operator">,</span> <span class="variable">supersetof</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">4</span><span class="operator">));</span>
</pre>
<p>check that @$data contains at least 1 &quot;1&quot; and 1 &quot;4&quot;.</p>
<p>These are just special cases of the Set and Bag comparisons so they also
give you an <code>add()</code> method and they also have the same limitations when using
special comparisons inside them (see the NOTE in the <code>bag()</code> section).</p>
<p>
</p>
<h3><a name="all__expecteds_"><code>all(@expecteds)</code></a></h3>
<p>@expecteds is an array of expected structures.</p>
<p>This allows you to compare data against multiple expected results and make
sure each of them matches.</p>
<pre>
  cmp_deeply($got, all(isa(&quot;Person&quot;), methods(name =&gt; 'John')))</pre>
<p>is equivalent to</p>
<pre>
  $got-&gt;isa(&quot;Person&quot;)
  $got-&gt;name eq 'John'</pre>
<p>If either test fails then the whole thing is considered a fail. This is a
short-circuit test, the testing is stopped after the first failure, although
in the future it may complete all tests so that diagnostics can be output
for all failures. When reporting failure, the parts are counted from 1.</p>
<p>Thanks to the magic of overloading, you can write</p>
<pre>
  all(isa(&quot;Person&quot;), methods(name =&gt; 'John'), re(&quot;^wi&quot;))</pre>
<p>as</p>
<pre>
  isa(&quot;Person&quot;) &amp; methods(name =&gt; 'John') | re(&quot;^wi&quot;)</pre>
<p>Note <strong>single</strong> | not double as || cannot be overloaded. This will only work
when there is a special comparison involved. If you write</p>
<pre>
  &quot;john&quot; | &quot;anne&quot; | &quot;robert&quot;</pre>
<p>Perl will turn this into</p>
<pre>
  <span class="string">"{onort"</span>
</pre>
<p>which is presumably not what you wanted. This is because Perl |s them
together as strings before Test::Deep gets a chance to do any overload
tricks.</p>
<p>
</p>
<h3><a name="any__expecteds_"><code>any(@expecteds)</code></a></h3>
<p>@expecteds is an array of expected structures.</p>
<p>This can be used to compare data against multiple expected results and make
sure that at least one of them matches. This is a short-circuit test so if
a test passes then none of the tests after that will be attempted.</p>
<p>You can also use overloading with | similarly to <code>all()</code>.</p>
<p>
</p>
<h3><a name="isa__class___isa__class_"><code>isa($class)</code>, <code>Isa($class)</code></a></h3>
<p>$class is a class name.</p>
<p>This uses UNIVERSAL::isa() to check that $got_v is blessed into the class
$class.</p>
<p><strong>NOTE:</strong> <code>Isa()</code> does exactly as documented here, but <code>isa()</code> is slightly
different. If <code>isa()</code> is called with 1 argument it falls through to
<code>Isa()</code>. If <code>isa()</code> called with 2 arguments, it falls through to
UNIVERSAL::isa. This is to prevent breakage when you import <code>isa()</code> into
a package that is used as a class. Without this, anyone calling
<code>Class-&gt;isa($other_class)</code> would get the wrong answer. This is a
hack to patch over the fact that isa is exported by default.</p>
<p>
</p>
<h3><a name="array_each__thing_"><code>array_each($thing)</code></a></h3>
<p>$thing is a structure to be compared against.</p>
<p>&lt;$got_v&gt; must be an array reference. Each element of it will be compared to
$thing. This is useful when you have an array of similar things, for example
objects of a known type and you don't want to have to repeat the same test
for each one.</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$common_tests</span> <span class="operator">=</span> <span class="variable">all</span><span class="operator">(</span>
     <span class="variable">isa</span><span class="operator">(</span><span class="string">"MyFile"</span><span class="operator">),</span>
     <span class="variable">methods</span><span class="operator">(</span>
       <span class="string">handle</span> <span class="operator">=&gt;</span> <span class="variable">isa</span><span class="operator">(</span><span class="string">"IO::Handle"</span><span class="operator">)</span>
       <span class="string">filename</span> <span class="operator">=&gt;</span> <span class="variable">re</span><span class="operator">(</span><span class="string">"^/home/ted/tmp"</span><span class="operator">),</span>
    <span class="operator">)</span>
  <span class="operator">);</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$got</span><span class="operator">,</span> <span class="variable">array_each</span><span class="operator">(</span><span class="variable">$common_tests</span><span class="operator">));</span>
</pre>
<p>is similar to</p>
<pre>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$got_v</span> <span class="operator">(</span><span class="variable">@$got</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$got_v</span><span class="operator">,</span> <span class="variable">$common_tests</span><span class="operator">)</span>
  <span class="operator">}</span>
</pre>
<p>Except it will not explode is $got is not an array reference. It will check
that each of the objects in @$got is a MyFile and that each one gives the
correct results for it's methods.</p>
<p>You could go further, if for example there were 3 files and you knew the
size of each one you could do this</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$got</span><span class="operator">,</span>
    <span class="variable">all</span><span class="operator">(</span>
      <span class="variable">array_each</span><span class="operator">(</span><span class="variable">$common_tests</span><span class="operator">),</span>
      <span class="operator">[</span>
        <span class="variable">methods</span><span class="operator">(</span><span class="string">size</span> <span class="operator">=&gt;</span> <span class="number">1000</span><span class="operator">),</span>
        <span class="variable">methods</span><span class="operator">(</span><span class="string">size</span> <span class="operator">=&gt;</span> <span class="number">200</span><span class="operator">),</span>
        <span class="variable">methods</span><span class="operator">(</span><span class="string">size</span> <span class="operator">=&gt;</span> <span class="number">20</span><span class="operator">)</span>
      <span class="operator">]</span>
    <span class="operator">)</span>
  <span class="operator">)</span>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="variable">$got</span><span class="operator">,</span> <span class="variable">array_each</span><span class="operator">(</span><span class="variable">$structure</span><span class="operator">));</span>
</pre>
<p>
</p>
<h3><a name="str__string_"><code>str($string)</code></a></h3>
<p>$string is a string.</p>
<p>This will stringify <code>$got_v</code> and compare it to <code>$string</code> using <code>eq</code>, even
if $got_v is a ref. It is useful for checking the stringified value of an
overloaded reference.</p>
<p>
</p>
<h3><a name="num__number___tolerance_">num($number, $tolerance)</a></h3>
<p>$number is a number.
$tolerance is an optional number.</p>
<p>This will add 0 to <code>$got_v</code> and check if it's numerically equal to
<code>$number</code>, even if $got_v is a ref. It is useful for checking the numerical
value of an overloaded reference. If $tolerance is supplied then this will
check that $got_v and $exp_v are less than $tolerance apart. This is useful
when comparing floating point numbers as rounding errors can make it hard or
impossible for $got_v to be exactly equal to $exp_v. When $tolerance is
supplied, the test passes if <a href="../../../lib/pods/perlfunc.html#abs"><code>abs($got_v - $exp_v) &lt;= $tolerance</code></a>.</p>
<p><strong>Note</strong> in Perl, <code>&quot;12blah&quot; == 12</code> because Perl will be smart and convert
&quot;12blah&quot; into 12. You may not want this. There was a strict mode but that is
now gone. A &quot;lookslike s number&quot; test will replace it soon. Until then you
can usually just use the <code>string()</code> comparison to be more strict. This will
work fine for almost all situations, however it will not work when &lt;$got_v&gt;
is an overloaded value who's string and numerical values differ.</p>
<p>
</p>
<h3><a name="bool__value_"><code>bool($value)</code></a></h3>
<p>$value is anything you like but it's probably best to use 0 or 1</p>
<p>This will check that <code>$got_v</code> and <code>$value</code> have the same truth value, that
is they will give the same result when used in boolean context, like in an
<code>if()</code> statement.</p>
<p>
</p>
<h3><a name="code___subref_">code(\&amp;subref)</a></h3>
<p>\&amp;subref is a reference to a subroutine which will be passed a single
argument, it then should return a true or false and possibly a string</p>
<p>This will pass <code>$got_v</code> to the subroutine which returns true or false to
indicate a pass or fail. Fails can be accompanied by a diagnostic string
which gives an explanation of why it's a fail.</p>
<pre>
  <span class="keyword">sub</span><span class="variable"> check_name
  </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$name</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$boss</span><span class="operator">-&gt;</span><span class="variable">likes</span><span class="operator">(</span><span class="variable">$name</span><span class="operator">))</span>
    <span class="operator">{</span>
      <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">else</span>
    <span class="operator">{</span>
      <span class="keyword">return</span> <span class="operator">(</span><span class="number">0</span><span class="operator">,</span> <span class="string">"the boss doesn't like your name"</span><span class="operator">);</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="string">"Brian"</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">check_name</span><span class="operator">);</span>
</pre>
<p>
</p>
<hr />
<h1><a name="diagnostic_functions">DIAGNOSTIC FUNCTIONS</a></h1>
<p>
</p>
<h3><a name="my__reason___deep_diag__stack_">my $reason = <code>deep_diag($stack)</code></a></h3>
<p><code>$stack</code> is a value returned by cmp_details.  Do not call this function
if cmp_details returned a true value for <code>$ok</code>.</p>
<p><code>deep_diag()</code> returns a human readable string describing how the
comparison failed.</p>
<p>
</p>
<hr />
<h1><a name="another_example">ANOTHER EXAMPLE</a></h1>
<p>You've written a module to handle people and their film interests. Say you
have a function that returns an array of people from a query, each person is
a hash with 2 keys: Name and Age and the array is sorted by Name. You can do</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$result</span><span class="operator">,</span>
    <span class="operator">[</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">'Anne'</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">26</span><span class="operator">}</span><span class="operator">,</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">"Bill"</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">47</span><span class="operator">}</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">'John'</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">25</span><span class="operator">}</span><span class="operator">,</span>
    <span class="operator">]</span>
  <span class="operator">);</span>
</pre>
<p>Soon after, your query function changes and all the results now have an ID
field. Now your test is failing again because you left out ID from each of
the hashes. The problem is that the IDs are generated by the database and
you have no way of knowing what each person's ID is. With Test::Deep you can
change your query to</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$result</span><span class="operator">,</span>
    <span class="operator">[</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">'John'</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">25</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">()</span><span class="operator">}</span><span class="operator">,</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">'Anne'</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">26</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">()</span><span class="operator">}</span><span class="operator">,</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">"Bill"</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">47</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">()</span><span class="operator">}</span>
    <span class="operator">]</span>
  <span class="operator">);</span>
</pre>
<p>But your test still fails. Now, because you're using a database, you no
longer know what order the people will appear in. You could add a sort into
the database query but that could slow down your application. Instead you
can get Test::Deep to ignore the order of the array by doing a bag
comparison instead.</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
    <span class="variable">$result</span><span class="operator">,</span>
    <span class="variable">bag</span><span class="operator">(</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">'John'</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">25</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">()</span><span class="operator">}</span><span class="operator">,</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">'Anne'</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">26</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">()</span><span class="operator">}</span><span class="operator">,</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">"Bill"</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">47</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">()</span><span class="operator">}</span>
    <span class="operator">)</span>
  <span class="operator">);</span>
</pre>
<p>Finally person gets even more complicated and includes a new field called
Movies, this is a list of movies that the person has seen recently, again
these movies could also come back in any order so we need a bag inside our
other bag comparison, giving us something like</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span>
  <span class="variable">$result</span><span class="operator">,</span>
    <span class="variable">bag</span><span class="operator">(</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">'John'</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">25</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">(),</span> <span class="string">Movies</span> <span class="operator">=&gt;</span> <span class="variable">bag</span><span class="operator">(...)</span><span class="operator">}</span><span class="operator">,</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">'Anne'</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">26</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">(),</span> <span class="string">Movies</span> <span class="operator">=&gt;</span> <span class="variable">bag</span><span class="operator">(...)</span><span class="operator">}</span><span class="operator">,</span>
      <span class="operator">{</span><span class="string">Name</span> <span class="operator">=&gt;</span> <span class="string">"Bill"</span><span class="operator">,</span> <span class="string">Age</span> <span class="operator">=&gt;</span> <span class="number">47</span><span class="operator">,</span> <span class="string">ID</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">(),</span> <span class="string">Movies</span> <span class="operator">=&gt;</span> <span class="variable">bag</span><span class="operator">(...)</span><span class="operator">}</span>
    <span class="operator">)</span>
  <span class="operator">);</span>
</pre>
<p>
</p>
<hr />
<h1><a name="using_test__deep_with_test__builder">USING TEST::DEEP WITH TEST::BUILDER</a></h1>
<p>Combining <code>cmp_details</code> and <code>test_diag</code> makes it possible to use
Test::Deep in your own test classes.</p>
<p>In a <a href="../../../lib/Test/Builder.html">the Test::Builder manpage</a> subclass, create a test method in the following
form:</p>
<pre>
  <span class="keyword">sub</span><span class="variable"> behaves_ok </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$expected</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$test_name</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">my</span> <span class="variable">$got</span> <span class="operator">=</span> <span class="variable">do_the_important_work_here</span><span class="operator">();</span>
</pre>
<pre>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$ok</span><span class="operator">,</span> <span class="variable">$stack</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">cmp_details</span><span class="operator">(</span><span class="variable">$got</span><span class="operator">,</span> <span class="variable">$expected</span><span class="operator">);</span>
    <span class="keyword">unless</span> <span class="operator">(</span><span class="variable">$Test</span><span class="operator">-&gt;</span><span class="variable">ok</span><span class="operator">(</span><span class="variable">$ok</span><span class="operator">,</span> <span class="variable">$test_name</span><span class="operator">))</span> <span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$diag</span> <span class="operator">=</span> <span class="variable">deep_diag</span><span class="operator">(</span><span class="variable">$stack</span><span class="operator">);</span>
      <span class="variable">$Test</span><span class="operator">-&gt;</span><span class="variable">diag</span><span class="operator">(</span><span class="variable">$diag</span><span class="operator">);</span>
    <span class="operator">}</span>
      <span class="operator">}</span>
</pre>
<p>As the subclass defines a test class, not tests themselves, make sure it
uses <a href="../../../cpan/build/Test-Deep-0.109-wclwY5/blib/html/site/lib/Test/Deep/NoTest.html">the Test::Deep::NoTest manpage</a>, not <code>Test::Deep</code> itself.</p>
<p>
</p>
<hr />
<h1><a name="limitations">LIMITATIONS</a></h1>
<p>Currently any CODE, GLOB or IO refs will be compared using <code>shallow()</code>, which
means only their memory addresses are compared.</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>There is a bug in set and bag compare to do with competing SCs. It only
occurs when you put certain special comparisons inside bag or set
comparisons you don't need to worry about it. The full details are in the
<code>bag()</code> docs. It will be fixed in an upcoming version.</p>
<p>
</p>
<hr />
<h1><a name="what_are_special_comparisons">WHAT ARE SPECIAL COMPARISONS?</a></h1>
<p>A special comparison (SC) is simply an object that inherits from
Test::Deep::Cmp. Whenever <code>$expected_v</code> is an SC then instead of checking
<code>$got_v eq $expected_v</code>, we pass control over to the SC and let it do it's
thing.</p>
<p>Test::Deep exports lots of SC constructors, to make it easy for you to use
them in your test scripts. For example is <code>re(&quot;hello&quot;)</code> is just a handy way
of creating a Test::Deep::Regexp object that will match any string containing
&quot;hello&quot;. So</p>
<pre>
  <span class="variable">cmp_deeply</span><span class="operator">(</span><span class="operator">[</span> <span class="string">'a'</span><span class="operator">,</span> <span class="string">'b'</span><span class="operator">,</span> <span class="string">'hello world'</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">[</span><span class="string">'a'</span><span class="operator">,</span> <span class="string">'b'</span><span class="operator">,</span> <span class="variable">re</span><span class="operator">(</span><span class="string">"^hello"</span><span class="operator">)</span><span class="operator">]</span><span class="operator">);</span>
</pre>
<p>will check <code>'a' eq 'a'</code>, <code>'b' eq 'b'</code> but when it comes to comparing
<code>'hello world'</code> and <code>re(&quot;^hello&quot;)</code> it will see that
$expected_v is an SC and so will pass control to the Test::Deep::Regexp class
by do something like <code>$expected_v-&gt;descend($got_v)</code>. The <code>descend()</code>
method should just return true or false.</p>
<p>This gives you enough to write your own SCs but I haven't documented how
diagnostics works because it's about to get an overhaul.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="../../../lib/Test/More.html">the Test::More manpage</a></p>
<p>
</p>
<hr />
<h1><a name="maintainer">MAINTAINER</a></h1>
<pre>
  Ricardo Signes &lt;rjbs@cpan.org&gt;</pre>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Fergal Daly &lt;<a href="mailto:fergal@esatclear.ie">fergal@esatclear.ie</a>&gt;, with thanks to Michael G Schwern
for Test::More's is_deeply function which inspired this.</p>
<p><strong>Please</strong> do not bother Fergal Daly with bug reports.  Send them to the
maintainer (above) or submit them at <em>the request tracker</em>.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>Copyright 2003, 2004 by Fergal Daly &lt;<a href="mailto:fergal@esatclear.ie">fergal@esatclear.ie</a>&gt;.</p>
<p>This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.</p>
<p>See <em class="file"><a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a></em></p>

</body>

</html>
